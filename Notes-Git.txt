------------------------------------------
| *************** Config *************** |
------------------------------------------
There is a local and global config. Global applies to all 
repositories and local within a repo directory.

The following configuration levels are available:

--local
By default, git config will write to a local level if no configuration option is passed. 
Local level configuration is applied to the context repository git config gets invoked in. 
Local configuration values are stored in a file that can be found in the repo's .git directory: .git/config

 --global
Global level configuration is user-specific, meaning it is applied to an operating system user. 
Global configuration values are stored in a file that is located in a user's home directory. ~ /.gitconfig on unix systems and C:\Users\\.gitconfig on windows

 --system
System-level configuration is applied across an entire machine. This covers all users on an operating system and all repos. 
The system level configuration file lives in a gitconfig file off the system root path. $(prefix)/etc/gitconfig on unix systems. 
On windows this file can be found at C:\Documents and Settings\All Users\Application Data\Git\config on Windows XP, and in C:\ProgramData\Git\config on Windows Vista and newer.

Thus the order of priority for configuration levels is: local, global, system. This means when looking for a configuration value, Git will start at the local level and bubble up to the system level.

Listing a full config:
----------------------
	git config --list (shows all entries)

Editing a full config:
---------------------
	git config --global --edit

Show a config entry:
--------------------
	git config <key>
	git config user.email (show user email)
	git config remote.origin.url (shows remote origin url)

Writing a config entry:
-----------------------
	git config --<config level> <key> <value>
	git config --global user.name "Chris Harper" (sets a global username)
	git config --local fave.food "Curry" (sets a new key-vale pair within a repository context

Updating a config entry:
-----------------------
Current global config key-valeu pair: user.email=me@here.com
Needs to be:user.email=me@there.co.uk
Command:
	git config --global user.email "me@there.co.uk" 

Delete an entry:
----------------
	git config --global --unset <key>
	git config --global --unset core.excludesfile

Setting global text editor:
---------------------------
	git config --global core.editor "nano -w" (Nano)
	git config --global core.editor "vim" (ViMproved)

------------------------------------------
| *************** Remotes *************** |
------------------------------------------

Checking remote config:
----------------------
	git remote -v

Adding a remote: 
----------------
	git remote add <alias> <url>
	git remote add origin https://github.com/harperonline/git.git

Changing a remote: 
------------------
	git remote set-url <alias> <url>
	git remote set-url origin https://github.com/harperonline/git.git

Remove a remote:
----------------
	git remote remove <alias>
	git remote remove origin

-------------------------------------------
| *************** Branches *************** |
-------------------------------------------

Creating a new local branch (without switching):
------------------------------------------------
	git branch <branch name>
	git branch feature/featurename

Creating a new local branch (and switching):
--------------------------------------------
	git checkout -b <branch name>
	git checkout -b feature/featurename

Delete a local branch:
----------------------
	git branch -d <branch name>
	git branch -d feature/crapbranch

Delete a remote branch:
----------------------
	git push <alias> --delete <remote branch name>
	git push origin --delete feature/crapbranch

----------------------------------------
| *************** Stash *************** |
----------------------------------------
Git stash enables you to save your code without making a commit. How is this useful? Picture the following scenario:

You’ve already made three neat and tidy commits, but you also have some uncommitted code that’s quite messy; 
you won’t want to commit it without removing your debugging code first. Then, for some reason, you suddenly need to attend to another task and have to switch branches. 
This can often happen if you are on your main branch, and you have forgotten to create a new branch for your feature. 

A stash will only work for STAGED files.

Stash a staged file for later:
------------------------------
	git stash (do this with the branch that you wish to stash the files for later)

Show the available stashes:
---------------------------
	git stash list

Apply a stash when you return to your branch:
--------------------------------------------
git stash apply stash@{<stash ID>}
git stash apply stash@{0}

Drop a stash:
-------------
git stadh drop stash@{n}

Drop LATEST stash from top of list (effectivley {0}):
-----------------------------------------------------
git stash drop





